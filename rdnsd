#!/usr/bin/perl
#
# Copyright 2019 CentralNic Ltd. This program is free software; you can
# redistribute it and/or modify it under the same terms as Perl itself.
#
use Config::Simple;
use DBI;
use Getopt::Long;
use IO::File;
use List::Util qw(min max);
use Net::DNS;
use POSIX qw(setsid strftime floor);
use Pod::Usage;
use Sys::Syslog qw(:standard :macros);
use Time::HiRes qw(time sleep);
use threads;
use strict;
use vars qw($VERSION);

our $VERSION = '0.10';

#
# get config from command line:
#
my $cfile = '/etc/rdnsd/rdnsd.conf';
my $debug;
my $help;

GetOptions(
	'config=s' => \$cfile,
	'debug'    => \$debug,
	'help'     => \$help,
);

pod2usage('-verbose' => 99, '-sections' => 'USAGE|OPTIONS') if ($help);

#
# pre-compiled query packet
#
my $qpacket;

#
# load configuration
#
my $config;
load_config();

#
# sense check
#
if (!$config->{'Database'} && !$config->{'StatsFile'}) {
	die("ERROR: config must include either a 'Database' or 'StatsFile' directie.\n");

} elsif ($config->{'Servers'} && $config->{'Domains'}) {
	die("ERROR: Both 'Servers' and 'Domains' are present in config: please choose one or the other.\n");

} elsif ($config->{'Timeout'} > $config->{'Loop'}) {
	die(sprintf(
		"ERROR: value for 'Timeout' (%u) must not be more  than 'Loop' (%u).\n",
		$config->{'Timeout'},
		$config->{'Loop'}
	));

} elsif ($config->{'UpdateInterval'} <= $config->{'Loop'} * $config->{'Timeout'}) {
	die(sprintf(
		"ERROR: value for 'UpdateInterval' (%u) must be more than 'Loop' x 'Timeout' (%u x %u = %u).\n",
		$config->{'UpdateInterval'},
		$config->{'Loop'},
		$config->{'Timeout'},
		($config->{'Loop'} * $config->{'Timeout'})
	));

} elsif ($config->{'UpdateInterval'} <= 3 * $config->{'Loop'} * $config->{'Timeout'}) {
	warn(sprintf(
		"WARNING: value for 'UpdateInterval' (%u) should be at least three times the value of 'Loop' x 'Timeout' (3 x %u x %u = %u)\n",
		$config->{'UpdateInterval'},
		$config->{'Loop'},
		$config->{'Timeout'},
		(3 * $config->{'Loop'} * $config->{'Timeout'})
	));
}

#
# configure logging
#
openlog('rdnsd', 'pid', LOG_DAEMON);
setlogmask(LOG_UPTO(LOG_DEBUG));

debug('rdnsd v%s starting', $VERSION);

#
# these are populated by update_serverlist():
#
my @servers;
my $reload;
my $refresh;

#
# cache which stores A/AAAA addresses of nameservers
#
my $cache = {};

#
# database and statement handles
#
my ($dbh, $sth);

#
# generate list of servers
#
update_serverlist();

die('no servers found') if (scalar(@servers) < 1);

#
# we put statistics data in here
#
my $stats = {};

#
# optionally daemonize:
#
my $daemon;
unless ($debug) {
	if (fork() > 0) {
		exit 0;

	} else {
		setsid();
		chdir('/');
		$0 = '[rdnsd]';

	}
	$daemon = 1;
}

#
# write our PID to a file:
#
if (!open(PIDFILE, '>'.$config->{'PidFile'})) {
	die("Error opening '$config->{'PidFile'}': $!");

} else {
	print PIDFILE $$."\n";
	close(PIDFILE);

	debug('wrote %s', $config->{'PidFile'});
}

#
# HUP handler:
#
$SIG{'HUP'} = sub {
	debug('received SIGHUP');
	$reload = 1;
	$refresh = 0;
};

#
# initialise stats update timer
#
my $updated = time();

#
# loop forever:
#
debug('entering main loop');
main_loop() while (1);

exit;

#
# main loop function
#
sub main_loop {
	#
	# refresh server list if necessary
	#
	update_serverlist() if ($refresh <= time());

	#
	# reload config if we've received a SIGHUP
	#
	load_config() if ($reload);

	my $t0 = time();

	#
	# spawn threads
	#
	my %threads;
	foreach my $ns (sort(@servers)) {
		my @ips = resolve($ns);
		$threads{$ns} = threads->create(\&time_query, @ips);
	}

	#
	# gather threads
	#
	foreach my $ns (sort(@servers)) {
		$stats->{$ns}->{'count'}++;

		my $dt = $threads{$ns}->join;

		if (!$dt) {
			debug('no answer from %s', uc($ns));

		} else {
			debug('answer received from %s in %ums', uc($ns), 1000 * $dt);

			$stats->{$ns}->{'time'} += $dt;
			$stats->{$ns}->{'success'}++;
			push(@{$stats->{$ns}->{'times'}}, $dt);
		}
	}

	my $dt = (time() - $t0);
	debug('main_loop() completed in %dms', 1000 * $dt);

	#
	# sleep if we need to
	#
	sleep($config->{'Loop'}-$dt) if ($dt < $config->{'Loop'});

	#
	# update stats
	#
	update_stats() if (time() - $updated >= $config->{'UpdateInterval'});
}

#
# send a DNS query and return the amount of time it took (or undef if no
# answer was received within the timeout window)
#
# we accept multiple arguments since servers may be multi-homed. this
# function should only ever receive IP addresses as arguments, otherwise
# the RTT will erroneously include the time taken to resolve the name
#
sub time_query {
	my @servers = @_;

	return undef if (scalar(@servers) < 1);

	#
	# construct and configure a new resolver object
	#
	my $resolver = Net::DNS::Resolver->new;
	$resolver->retry(0);
	$resolver->usevc('tcp' eq $config->{'Protocol'});
	$resolver->udp_timeout($config->{'Timeout'});
	$resolver->tcp_timeout($config->{'Timeout'});
	$resolver->persistent_udp(0);
	$resolver->persistent_tcp(0);
	$resolver->force_v4(4 == $config->{'AddressFamily'});
	$resolver->force_v6(6 == $config->{'AddressFamily'});

	#
	# specify nameservers
	#
	$resolver->nameservers(@servers);

	my $result;

	my $t0 = time();

	#
	# send query
	#
	eval {
		$result = $resolver->send($qpacket);
	};

	my $dt = (time() - $t0);

	if (!$result) {
		return undef;

	} else {
		return $dt;

	}
}

#
# emit debug message
#
sub debug {
	my ($fmt, @args) = @_;
	my $message = sprintf($fmt, @args);
	syslog(LOG_DEBUG, $message);
	print(STDERR $message."\n") if ($debug);
}

#
# load configuration, which may be at startup time, or in response
# to a SIGHUP:
#
sub load_config {
	debug('loading configuration from %s', $cfile);

	#
	# get config from config file:
	#
	my $ini = Config::Simple->new('syntax' => 'simple');
	$ini->read($cfile);

	#
	# copy values and set defaults for missing entries
	#
	$config->{'UpdateInterval'}	= $ini->param('UpdateInterval')			|| 293;
	$config->{'PidFile'}		= $ini->param('PidFile')			|| '/var/run/rdnsd/rdnsd.pid';
	$config->{'Database'}		= $ini->param('Database')			|| '/var/run/rdnsd/rdnsd.sqlite';
	$config->{'Percentile'}		= $ini->param('Percentile')			|| undef;
	$config->{'AddressFamily'}	= $ini->param('AddressFamily')			|| 4;
	$config->{'Protocol'}		= $ini->param('Protocol')			|| 'udp';
	$config->{'Loop'}		= $ini->param('Loop')				|| 3;
	$config->{'Timeout'}		= $ini->param('Timeout')			|| 1;
	$config->{'Recurse'}		= $ini->param('Recurse') eq 'true'		|| undef;
	$config->{'Question'}		= $ini->param('Question')			|| '. A IN';
	$config->{'Servers'}		= $ini->param('Servers')			|| undef;
	$config->{'Domains'}		= $ini->param('Domains')			|| undef;
	$config->{'StatsFile'}		= $ini->param('StatsFile')			|| undef;

	#
	# configure question packet
	#
	my @question = split(/\s+/, $config->{'Question'});
	$qpacket = Net::DNS::Packet->new(@question);
	$qpacket->header->rd($config->{'Recurse'});

	$reload = undef;
}

#
# generate list of servers, which may be at startup time, in response
# to a SIGHUP, or because a DNS TTL has been reached:
#
sub update_serverlist {
	if ($config->{'Servers'}) {
		# statically defined server list, never refresh
		$refresh = -1;

		@servers = ('ARRAY' eq ref($config->{'Servers'}) ? @{$config->{'Servers'}} : split(/\s*,\s*/, $config->{'Servers'}));

	} else {
		@servers = ();

		my $resolver = Net::DNS::Resolver->new;

		#
		# start with a high value
		#
		my $minttl = ~0;

		my @domains = ('ARRAY' eq ref($config->{'Domains'}) ? @{$config->{'Domains'}} : split(/\s*,\s*/, $config->{'Domains'}));
		foreach my $domain (@domains) {
			my $answer = $resolver->query('_dns._udp.'.$domain, 'SRV');
			if ($answer) {
				foreach my $rr (grep { 'SRV' eq $_->type } $answer->answer) {
					push(@servers, $rr->target);

					#
					# reduce TTL if we see a lower value
					#
					$minttl = $rr->ttl if ($rr->ttl < $minttl);
				}
			}
		}

		#
		# if no servers return, retry after 60s, otherwise,
		# refresh after the shortest TTL observed in the answer
		# section
		#
		$refresh = time() + (scalar(@servers) < 1 ? 60 : $minttl);
		debug('server list updated; will be refreshed at %s', scalar(localtime($refresh)));
	}
}

#
# write stats to the database (and the legacy stats file if configured)
#
sub update_stats {

	if ($config->{'Database'}) {
		if (!$dbh) {
			$dbh = DBI->connect('dbi:SQLite:dbname='.$config->{'Database'}, '', '', { 'RaiseError' => 1, 'AutoCommit' => 0 });
			$dbh->do("CREATE TABLE IF NOT EXISTS rdnsd (
				id INTEGER NOT NULL PRIMARY KEY,
				start_time DATETIME NOT NULL,
				end_time DATETIME NOT NULL,
				host VARCHAR(255) NOT NULL,
				family INTEGER NOT NULL DEFAULT 4,
				proto CHAR(3) NOT NULL DEFAULT 'udp',
				count INTEGER NOT NULL,
				success INTEGER NOT NULL,
				rate DECIMAL(3,2) NOT NULL,
				min_time INTEGER NOT NULL,
				time INTEGER NOT NULL,
				max_time INTEGER NOT NULL,
				percentile_time INTEGER DEFAULT NULL
			)");
			$dbh->do('CREATE INDEX IF NOT EXISTS host_idx ON rdnsd(host)');
			$dbh->do('CREATE INDEX IF NOT EXISTS start_time_idx ON rdnsd(start_time)');
			$dbh->do('CREATE INDEX IF NOT EXISTS end_time_idx ON rdnsd(end_time)');
			$dbh->do('CREATE INDEX IF NOT EXISTS family_idx ON rdnsd(family)');
			$dbh->do('CREATE INDEX IF NOT EXISTS proto_idx ON rdnsd(proto)');

			$sth = $dbh->prepare('INSERT
						INTO rdnsd (start_time, end_time, host, family, proto, count, success, rate, min_time, time, max_time, percentile_time)
						VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');

			debug('initialised database in %s', $config->{'Database'});
		}

	} elsif ($dbh) {
		#
		# disconnect from the database
		#
		$dbh->disconnect;
		undef($dbh);
		undef($sth) if ($sth);

	}

	my $fh;
	if ($config->{'StatsFile'}) {
		$fh = IO::File->new($config->{'StatsFile'}, 'w');
	}

	foreach my $ns (sort(@servers)) {

		#
		# no stats for this server, ignore it
		#
		next if ($stats->{$ns}->{'count'} < 1);

		#
		# compute success rate and average RTT
		#
		my $rate = ($stats->{$ns}->{'success'} / $stats->{$ns}->{'count'});
		my $time = floor(1000 * $stats->{$ns}->{'time'} / $stats->{$ns}->{'count'});

		my @times = ($rate > 0 ? sort(@{$stats->{$ns}->{'times'}}) : ());

		my $ptime;
		if ($config->{'Percentile'}) {
			#
			# find the position in the array which corresponds to the percentile
			#
			my $pos = floor(scalar(@times) * $config->{'Percentile'} / 100) - 1;

			#
			# compute percentile time
			#
			$ptime = floor(1000 * $times[$pos]);
		}

		#
		# insert into database
		#
		if ($sth) {
			$sth->execute(
				lc($ns),
				strftime('%Y-%m-%d %H:%M:%S', localtime($updated)),	# times are in the system's configured time zone
				strftime('%Y-%m-%d %H:%M:%S', localtime(time())),	# times are in the system's configured time zone
				int($config->{'AddressFamily'}),
				lc($config->{'Protocol'}),
				int($stats->{$ns}->{'count'}),
				int($stats->{$ns}->{'success'}),
				sprintf('%f', $rate),
				int(1000 * min(@times)),
				int($time),
				int(1000 * max(@times)),
				($ptime ? int($ptime) : undef),
			);
		}

		#
		# write line to file
		#
		if ($fh) {
			my $line = sprintf('%s %0.2f %d', $ns, $rate, $time);
			$line .= sprintf(' %d', $ptime) if defined($ptime);

			$fh->print($line."\n");
		}
	}

	#
	# commit changes
	#
	if ($dbh) {
		$dbh->commit;
		debug("updated '%s'", $config->{'Database'});
	}

	#
	# close file
	#
	if ($fh) {
		$fh->close;
		debug("wrote stats to '%s'", $config->{'StatsFile'});
	}

	#
	# reset timer and stats
	#
	if ($dbh || $fh) {
		$updated = time();
		$stats = {};
	}
}

#
# resolve a server name to IPv4 or IPv6 addresses, using a cached value
# if possible will attempt to detect literal IPs to avoid doing a DNS
# lookup
#
sub resolve {
	my $name = lc(shift);
	my $type = shift || 'A';

	if (($name =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/ && 'A' eq $type) || ($name =~ /^[0-9a-f:]+$/i && 'AAAA' eq $type)) {
		#
		# IP literal, just return it
		#
		return ($name);

	} else {
		if (!defined($cache->{$name}->{$type}) || $cache->{$name}->{$type}->{'expires'} < time()) {
			my $resolver = Net::DNS::Resolver->new;
			my $answer = $resolver->query($name.'.', $type);
			if ($answer) {
				#
				# start with a high value
				#
				my $minttl = ~0;

				my @addrs;
				foreach my $rr (grep { $type eq $_->type} $answer->answer) {
					debug('address %s for %s expires in %us', $rr->address, $name, $rr->ttl);
					#
					# add address to list
					#
					push(@addrs, $rr->address);

					#
					# reduce TTL if we see a lower
					# value
					#
					$minttl = $rr->ttl if ($rr->ttl < $minttl);
				}

				#
				# store address data (and expiry time)
				# in cache
				#
				$cache->{$name}->{$type} = {
					'addrs'   => \@addrs,
					'expires' => time() + $minttl,
				}

			} else {
				debug("unable to resolve '%s'", $name);

				if (!defined($cache->{$name}->{$type})) {
					$cache->{$name}->{$type} = {
						'addrs'   => [],
						'expires' => time(),
					}
				}
			}
		}

		return @{$cache->{$name}->{$type}->{'addrs'}};
	}
}

__END__

=pod

=head1 NAME

rdnsd is a remote DNS server monitoring system.

=head1 DESCRIPTION

C<rdnsd> can be used to monitor the availability and responsiveness of
remote DNS servers. Given a list of DNS servers, it will periodically
query each server and record whether a response was received, and how
quickly. This information can then be queried by querying an SQLite
database.

=head1 USAGE

	C<rdnsd> OPTIONS

=head1 OPTIONS

The following command line options are supported.

=over

=item * C<--help>

Display help text.

=item * C<--config=FILE>

Specify the configuration file. See L<CONFIGURATION FILE> for further
details. If not specified, C</etc/rdnsd/rdnsd.conf> is used.

=item * C<--debug>

Enable debug mode. C<rdnsd> will not daemonise and will emit debugging
information to STDERR.

=head1 CONFIGURATION FILE

C<rdnsd> must be configured using a configuration file. The following
is an example:

	UpdateInterval	293
	PidFile		/var/run/rdnsd/rdnsd.pid
	Database	/var/run/rdnsd/rdnsd.db
	Percentile	95
	AddressFamily	4
	Protocol	udp
	Loop		3
	Timeout		1
	Recurse		false
	Question	. A IN
	Servers		ns1.example.com,ns2.example.net
	Domains		example.com

The directives are explained below.

=over

=item * C<UpdateInterval TIME>

Default: C<293>

This parameter tells C<rdnsd> to automatically update the statistics
database every C<TIME> seconds. This value B<MUST> be more than
C<Loop x Timeout> seconds, and B<SHOULD> be at least three times that
value.

=item * C<PidFile /path/to/pid/file>

Default: C</var/run/rdnsd/rdnsd.pid>

The file where C<rdnsd> will write its pid.

=item * C<Database FILE>

Default: C</var/run/rdnsd/rdnsd.sqlite>

If set, C<rdnsd> will create an SQLite database at the specified file
and write statistics to it. The database will contain a single table
named C<rdnsd>, which will contain the following columns:

=over

=item * C<id> - unique row ID

=item * C<start_time> - date/time the monitoring interval began

=item * C<ends_time> - date/time the monitoring interval ended

=item * C<host> - server name

=item * C<family> - IP version (4 or 6)

=item * C<proto> - transport protocol (UDP or TCP)

=item * C<count> - number of queries sent to the server

=item * C<success> - number of successful queries

=item * C<rate> - response rate as a decimal (0.00 - 1.00) (equivalent
to C<success / rate>)

=item * C<min_time> - lowest observed RTT in milliseconds

=item * C<time> - average RTT in milliseconds

=item * C<time> - highest observed RTT in milliseconds

=item * C<percentile_time> - average RTT in milliseconds at the
configured percentile.

=back

=item * C<Percentile PERCENTILE>

Default: none

If this option is set, C<rdnsd> will calculate the response time at the
given percentile.

=item * C<AddressFamily (4|6)>

Default: C<4>

Specifies whether to prefer IPv4 or IPv6 when talking to nameservers, if
the servers are identified by name rather than address (or when loaded
from SRV records). If not defined, the default behaviour is to prefer
IPv4.

=item * C<Protocol (udp|tcp)>

Default: C<udp>

Specify the transport protocol (UDP or TCP) to use.

=item * C<Loop SECONDS>

Default: C<3>

This specifies the length of the main loop. If this is set to 2, then
each server will be checked every 2 seconds. This value can be a decimal
fraction, eg 0.25.

=item * C<Timeout SECONDS>

Default: C<1>

This specifies the timeout for DNS queries. A server will be considered
down if it does not respond within this amount of time. This value
B<MUST> be less than the value of C<Loop>.

=item * C<Recurse (true|false)>

Default: C<false>

Enable recursion (i.e. set the `rd` bit on the queries sent to servers).

=item * C<Question QUESTION>

Default: C<example.com. IN A>

Specify the DNS question. The format is "QNAME QCLASS QTYPE".

=item * C<Servers SERVERS>

Default: none

Specify the servers to be checked. You can either specify a server name
(which will be resolved to a set of IP addresses), or literal IPv4 or
IPv6 addresses.

This directive can't be used at the same time as the C<Domains>
directive.

=item * C<Domains DOMAINS>

Default: none

Rather than specifying a list of nameservers, you can provide a list of
domains instead. For each domain, C<rdnsd> will query for C<SRV> records
for C<_dns._udp> under the domain and use the targets of any C<SRV>
records returned.

The server list will be updated when the TTL on the C<SRV> records
expires.

This directive can't be used at the same time as the C<Servers>
directive.

=item * C<StatsFile /path/to/stats/file>

Default: none

B<Note:> this is a legacy option to provide backwards compatibility.

It specifies a file to which C<rdnsd> will write statistics.

See L<OBTAINING STATISTICS> for further information.

=back

=head1 RELOADING CONFIGURATION

C<rdnsd> will reload its configuration if you send it a C<SIGHUP>:

	$ kill -HUP `cat /path/to/pid/file`

=head1 OBTAINING STATISTICS

Every C<UpdateInterval> seconds, C<rdnsd> will write stats to the SQLite
database specified by C<Database>, and, if set, the file specified by
C<StatsFile>.

Once the database has been updated, C<rdnsd>'s internal data is reset,
so subsequent signals will produce fresh statistical data.

=head2 (LEGACY) STATISTICS FILE FORMAT

The (legacy) statistics file will contain one line for each server that
is being checked. Each line contains the nameserver checked, the
response rate as a decimal fraction, and the average response time (in
milliseconds), for example:

	ns0.example.com 1.00 25

If the C<Percentile> option is set in the config file (or the
C<--percentile> argument was given), an additional value will appear at
the end of the line:

	ns0.example.com 1.00 25 36

This value is the response time (in milliseconds) at the given
percentile.

Note that C<rdnsd> will not I<immediately> update the file upon
receiving the C<USR1> signal. You need to wait up to C<Loop> seconds
for the current loop iteration to complete before the stats file is
updated.

=head1 SEE ALSO

=over

=item * L<https://www.centralnic.com/>

=item * L<http://www.net-dns.org/>

=back

=head1 COPYRIGHT

C<rdnsd> is Copyright 2019 CentralNic Ltd. All rights reserved. This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
